{% extends 'layouts/base.html' %}

{% block title %} View {% endblock title %}

<!-- Specific CSS goes HERE -->
{% block stylesheets %}{% endblock stylesheets %}

{% block content %}

    <!-- Header -->
    <!-- <div class="header bg-gradient-primary pb-8 pt-5 pt-md-8"> -->
	
	<!-- <section style= "height:500px;"> -->
		
	<canvas id="potreecanvas" style="background: gray;left: 0px;position: absolute; z-index: -1;cursor: grab;tabindex="0"; border:1px solid;">
	</canvas>
	<input id="timeline" type="range" style=" width: 99%;background: transparent; position:relative; left:5px;" value="0">
    </input>
	<!-- </section> -->

	<!-- </div> -->


    <!-- <div class="container-fluid mt--7"> -->


    <!-- </div> -->
	
{% load static %}
	<script src="static/assets/potree/three.min.js"></script>
	<script src="static/assets/potree/OrbitControls.js"></script>
	<script src="static/assets/potree/potree.js"></script>
	<script>
		document.body.onload = function()
			{
				//three.js
				var scene = new THREE.Scene();

				//var canvas = document.createElement("canvas");
				var canvas = document.getElementById("potreecanvas");
				var sidenav = document.getElementById("sidenav");
				var timeline = document.getElementById("timeline");
				
				//canvas.style.position = "absolute";
				//canvas.style.top = "0px";
				//canvas.style.left = "0px";
				//canvas.style.width = "100%";
				//canvas.style.height = "100%";
				//document.body.appendChild(canvas);
				
				//var width = window.innerWidth;
				//var height = window.innerHeight;
				
				var width = canvas.width;
				var height = canvas.height;
				
				console.log(width);
				console.log(height);
				
				var camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100000);
				camera.position.set(-200, 150, -200 );

				var renderer = new THREE.WebGLRenderer(
				{
					canvas: canvas,
					alpha: true,
					logarithmicDepthBuffer: true,
					context: null,
					precision: "highp",
					premultipliedAlpha: true,
					antialias: true,
					preserveDrawingBuffer: false,
					powerPreference: "high-performance"
				});
				
				console.log(sidenav.style.width);
				console.log(canvas.height);
				<!-- renderer.setSize(canvas.width, canvas.height); -->

				//var geometry = new THREE.BoxBufferGeometry(25, 1, 25);
				//var material = new THREE.MeshBasicMaterial({color: 0x44AA44});
				//var cube = new THREE.Mesh(geometry, material);
				//cube.position.y = -2;
				//scene.add(cube);

				scene.add(new THREE.AmbientLight(0x404040));

				var controls = new THREE.OrbitControls(camera, canvas);
				controls.autoRotate = true;
				controls.update();

				var raycaster = new THREE.Raycaster();
				raycaster.params.Points.threshold = 1e-2;
				var normalized = new THREE.Vector2();

				canvas.onmousemove = function(event)
				{
					normalized.set((event.clientX / canvas.width) * 2 - 1, -(event.clientY / canvas.height) * 2 + 1);
					raycaster.setFromCamera(normalized, camera);
				}

				canvas.ondblclick = function(event)
				{
					var intesects = raycaster.intersectObject(scene, true);
					
					
					if(intesects.length > 0)
					{
						var geometry = new THREE.SphereBufferGeometry(0.1, 32, 32);
						var material = new THREE.MeshBasicMaterial({color: 0xAA4444});
						var sphere = new THREE.Mesh(geometry, material);
						sphere.position.copy(intesects[0].point);
						scene.add(sphere);
					}
				}

				Potree.Global.workerPath = "./static/assets/source";
				



				//loadPointCloud("data/lion_takanawa_ept_laz/ept.json", new THREE.Vector3(-4, -4, 3.0));
				//loadPointCloud("data/lion_takanawa_ept_bin/ept.json", new THREE.Vector3(-11, -4, 3.0));
				//loadPointCloud("data/lion_takanawa/cloud.js", new THREE.Vector3(-2, -3, 0.0));
				//loadPointCloud("data/lion_takanawa_las/cloud.js", new THREE.Vector3(3, -3, 0.0));
				//loadPointCloud("data/lion_takanawa_laz/cloud.js", new THREE.Vector3(8, -3, 0.0));
				//loadPointCloud("http://arena4d.uksouth.cloudapp.azure.com:8080/4e5059c4-f701-4a8f-8830-59e78a2c0816/BLK360 Sample.vpc");
				//"http://5.9.65.151/mschuetz/potree/resources/pointclouds/faro/skatepark/cloud.js"
				//"http://5.9.65.151/mschuetz/potree/resources/pointclouds/weiss/subseamanifold2/cloud.js"
				
				var counter = 1;
				
				function loadPointCloud(url, position)
				{

					Potree.loadPointCloud(url, "pointcloud", function(e)
					{
						var points = new Potree.Group();
						points.setPointBudget(500000);
						points.name = "objectName" + String(counter);
						//points.material.opacity = 0.0;
						//points.material.wireframe = false;
						
						scene.add(points);
	
						var pointcloud = e.pointcloud;

						if(position !== undefined)
						{
							pointcloud.position.copy(position);
						}

						var material = pointcloud.material;
						material.size = 2;
						material.pointColorType = Potree.PointColorType.RGB; //RGB | DEPTH | HEIGHT | POINT_INDEX | LOD | CLASSIFICATION
						material.pointSizeType = Potree.PointSizeType.ADAPTIVE; //ADAPTIVE | FIXED
						material.shape = Potree.PointShape.SQUARE; //CIRCLE | SQUARE

						points.add(pointcloud);
					});
				}
				
				
				
				function loadPC(s){
					
					var points = new Potree.Group();
					points.name = "objectName" + String(counter);
					points.setPointBudget(10000000)
					scene.add(points);

					Potree.loadPointCloud(s, name, function(data)
					{
						var pointcloud = data.pointcloud;
						points.add(pointcloud);
					});
					//counter = counter+1;
				}
				
				//var previous_value = -1;
				var count1 = 0;
				var count2 = 0;
				var count3 = 0;
				
				function loop()
				{
					//cube.rotation.y += 0.01;
					controls.update();
					renderer.render(scene, camera);

					requestAnimationFrame(loop);
					

					if(timeline.value<=34){
						count3 = 0
						count2 = 0;
						count1 = count1 + 1;
						if(count1 == 1){
							var object = scene.getObjectByName("objectName" + String(counter));
							scene.remove(object); 
							//loadPC("clouds/cloud1/cloud.js");
							//console.log("log");
							loadPointCloud("https://mojtaba1995.github.io/clouds/cloud1/cloud.js", new THREE.Vector3(-200, -150, -20));
						}
						//
					}
					if(timeline.value>34 && timeline.value<=67){
						count3 = 0
						count1 = 0;
						count2 = count2 + 1;
						if(count2 == 1){
							var object = scene.getObjectByName("objectName" + String(counter));
							scene.remove(object); 
							//console.log("log");
							//loadPC("clouds/cloud2/cloud.js");
							loadPointCloud("https://mojtaba1995.github.io//clouds/cloud2/cloud.js", new THREE.Vector3(-200, -150, -20));
						}
						//
					}
					if(timeline.value>67){
						count1 = 0;
						count2 = 0
						count3 = count3 + 1;
						if(count3 == 1){
							var object = scene.getObjectByName("objectName" + String(counter));
							scene.remove(object); 
							//console.log("log");
							//loadPC("clouds/cloud2/cloud.js");
							loadPointCloud("https://mojtaba1995.github.io//clouds/cloud3/cloud.js", new THREE.Vector3(-200, -150, -20));
						}
						//
					}
					
					//console.log(previous_value);
					//console.log(timeline.value);
					
					//previous_value = timeline.value;
					//console.log(timeline.value);
				};
				loop();

				//var width = window.innerWidth;
				//var height = window.innerHeight;
					
				//renderer.setSize(width, height);
				//camera.aspect = width / height;
				//camera.updateProjectionMatrix();

				document.body.onresize = function()
				{
					var width = window.innerWidth;
					var height = window.innerHeight;
					
					<!-- renderer.setSize(width, height); -->
					<!-- camera.aspect = width / height; -->
					<!-- camera.updateProjectionMatrix(); -->
				}
				<!-- document.body.onresize(); -->
				
				function resizeCanvas() {
					var width = 0;
					var height = 0;
					if (window.innerWidth >765){
					canvas.style.width = window.innerWidth -250 + "px";
					width = window.innerWidth -250;
					}else{
					canvas.style.width = window.innerWidth  + "px";
					width = window.innerWidth;
					}
					// artifical delay so innerHeight is correct
					setTimeout(function() {
						canvas.style.height = window.innerHeight  + "px";
						height =  window.innerHeight;
						renderer.setSize(width, height);
						camera.aspect = width / height;
						camera.updateProjectionMatrix();
						timeline.style.top = window.innerHeight -50  + "px";
					}, 0);
					

					console.log(width);
					console.log(height);
					
				};

				// Webkit/Blink will fire this on load, but Gecko doesn't.
				window.onresize = resizeCanvas;

				// So we fire it manually...
				resizeCanvas();	
				
			};
		</script>


{% endblock content %}


